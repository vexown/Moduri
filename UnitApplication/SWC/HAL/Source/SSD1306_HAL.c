#include "SSD1306_HAL.h"
#include "hardware/i2c.h"
#include <string.h>

SSD1306_t display;

// I2C Address for SSD1306 (adjust if necessary)
#define SSD1306_I2C_ADDR 0x3C

// Font data (5x7 font for characters ' ' to 'Z' and '0' to '9')
static const uint8_t font_5x7[][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // 32: Space
    {0x00, 0x00, 0x5F, 0x00, 0x00}, // 33: !
    {0x00, 0x07, 0x00, 0x07, 0x00}, // 34: "
    {0x14, 0x7F, 0x14, 0x7F, 0x14}, // 35: #
    {0x24, 0x2A, 0x7F, 0x2A, 0x12}, // 36: $
    {0x23, 0x13, 0x08, 0x64, 0x62}, // 37: %
    {0x36, 0x49, 0x55, 0x22, 0x50}, // 38: &
    {0x00, 0x05, 0x03, 0x00, 0x00}, // 39: '
    {0x00, 0x1C, 0x22, 0x41, 0x00}, // 40: (
    {0x00, 0x41, 0x22, 0x1C, 0x00}, // 41: )
    {0x14, 0x08, 0x3E, 0x08, 0x14}, // 42: *
    {0x08, 0x08, 0x3E, 0x08, 0x08}, // 43: +
    {0x00, 0x50, 0x30, 0x00, 0x00}, // 44: ,
    {0x08, 0x08, 0x08, 0x08, 0x08}, // 45: -
    {0x00, 0x60, 0x60, 0x00, 0x00}, // 46: .
    {0x20, 0x10, 0x08, 0x04, 0x02}, // 47: /
    {0x3E, 0x51, 0x49, 0x45, 0x3E}, // 48: 0
    {0x00, 0x42, 0x7F, 0x40, 0x00}, // 49: 1
    {0x42, 0x61, 0x51, 0x49, 0x46}, // 50: 2
    {0x21, 0x41, 0x45, 0x4B, 0x31}, // 51: 3
    {0x18, 0x14, 0x12, 0x7F, 0x10}, // 52: 4
    {0x27, 0x45, 0x45, 0x45, 0x39}, // 53: 5
    {0x3C, 0x4A, 0x49, 0x49, 0x30}, // 54: 6
    {0x01, 0x71, 0x09, 0x05, 0x03}, // 55: 7
    {0x36, 0x49, 0x49, 0x49, 0x36}, // 56: 8
    {0x06, 0x49, 0x49, 0x29, 0x1E}, // 57: 9
    {0x00, 0x36, 0x36, 0x00, 0x00}, // 58: :
    {0x00, 0x56, 0x36, 0x00, 0x00}, // 59: ;
    {0x08, 0x14, 0x22, 0x41, 0x00}, // 60: <
    {0x14, 0x14, 0x14, 0x14, 0x14}, // 61: =
    {0x00, 0x41, 0x22, 0x14, 0x08}, // 62: >
    {0x02, 0x01, 0x51, 0x09, 0x06}, // 63: ?
    {0x32, 0x49, 0x79, 0x41, 0x3E}, // 64: @
    {0x7E, 0x11, 0x11, 0x11, 0x7E}, // 65: A
    {0x7F, 0x49, 0x49, 0x49, 0x36}, // 66: B
    {0x3E, 0x41, 0x41, 0x41, 0x22}, // 67: C
    {0x7F, 0x41, 0x41, 0x22, 0x1C}, // 68: D
    {0x7F, 0x49, 0x49, 0x49, 0x41}, // 69: E
    {0x7F, 0x09, 0x09, 0x09, 0x01}, // 70: F
    {0x3E, 0x41, 0x49, 0x49, 0x7A}, // 71: G
    {0x7F, 0x08, 0x08, 0x08, 0x7F}, // 72: H
    {0x00, 0x41, 0x7F, 0x41, 0x00}, // 73: I
    {0x20, 0x40, 0x41, 0x3F, 0x01}, // 74: J
    {0x7F, 0x08, 0x14, 0x22, 0x41}, // 75: K
    {0x7F, 0x40, 0x40, 0x40, 0x40}, // 76: L
    {0x7F, 0x02, 0x04, 0x02, 0x7F}, // 77: M
    {0x7F, 0x04, 0x08, 0x10, 0x7F}, // 78: N
    {0x3E, 0x41, 0x41, 0x41, 0x3E}, // 79: O
    {0x7F, 0x09, 0x09, 0x09, 0x06}, // 80: P
    {0x3E, 0x41, 0x51, 0x21, 0x5E}, // 81: Q
    {0x7F, 0x09, 0x19, 0x29, 0x46}, // 82: R
    {0x46, 0x49, 0x49, 0x49, 0x31}, // 83: S
    {0x01, 0x01, 0x7F, 0x01, 0x01}, // 84: T
    {0x3F, 0x40, 0x40, 0x40, 0x3F}, // 85: U
    {0x1F, 0x20, 0x40, 0x20, 0x1F}, // 86: V
    {0x3F, 0x40, 0x30, 0x40, 0x3F}, // 87: W
    {0x63, 0x14, 0x08, 0x14, 0x63}, // 88: X
    {0x03, 0x04, 0x78, 0x04, 0x03}, // 89: Y
    {0x61, 0x51, 0x49, 0x45, 0x43}, // 90: Z
    {0x00, 0x7F, 0x41, 0x41, 0x00}, // 91: [
    {0x02, 0x04, 0x08, 0x10, 0x20}, // 92: backslash
    {0x00, 0x41, 0x41, 0x7F, 0x00}, // 93: ]
    {0x04, 0x02, 0x01, 0x02, 0x04}, // 94: ^
    {0x80, 0x80, 0x80, 0x80, 0x80}, // 95: _
    {0x00, 0x03, 0x05, 0x00, 0x00}, // 96: `
    {0x20, 0x54, 0x54, 0x54, 0x78}, // 97: a
    {0x7F, 0x48, 0x44, 0x44, 0x38}, // 98: b
    {0x38, 0x44, 0x44, 0x44, 0x20}, // 99: c
    {0x38, 0x44, 0x44, 0x48, 0x7F}, // 100: d
    {0x38, 0x54, 0x54, 0x54, 0x18}, // 101: e
    {0x08, 0x7E, 0x09, 0x01, 0x02}, // 102: f
    {0x08, 0x14, 0x54, 0x54, 0x3C}, // 103: g
    {0x7F, 0x08, 0x04, 0x04, 0x78}, // 104: h
    {0x00, 0x44, 0x7D, 0x40, 0x00}, // 105: i
    {0x20, 0x40, 0x44, 0x3D, 0x00}, // 106: j
    {0x7F, 0x10, 0x28, 0x44, 0x00}, // 107: k
    {0x00, 0x41, 0x7F, 0x40, 0x00}, // 108: l
    {0x7C, 0x04, 0x78, 0x04, 0x78}, // 109: m
    {0x7C, 0x08, 0x04, 0x04, 0x78}, // 110: n
    {0x38, 0x44, 0x44, 0x44, 0x38}, // 111: o
    {0x7C, 0x14, 0x14, 0x14, 0x08}, // 112: p
    {0x08, 0x14, 0x14, 0x18, 0x7C}, // 113: q
    {0x7C, 0x08, 0x04, 0x04, 0x08}, // 114: r
    {0x48, 0x54, 0x54, 0x54, 0x20}, // 115: s
    {0x04, 0x3F, 0x44, 0x40, 0x20}, // 116: t
    {0x3C, 0x40, 0x40, 0x20, 0x7C}, // 117: u
    {0x1C, 0x20, 0x40, 0x20, 0x1C}, // 118: v
    {0x3C, 0x40, 0x30, 0x40, 0x3C}, // 119: w
    {0x44, 0x28, 0x10, 0x28, 0x44}, // 120: x
    {0x0C, 0x50, 0x50, 0x50, 0x3C}, // 121: y
    {0x44, 0x64, 0x54, 0x4C, 0x44}, // 122: z
    {0x00, 0x08, 0x36, 0x41, 0x00}, // 123: {
    {0x00, 0x00, 0x7F, 0x00, 0x00}, // 124: |
    {0x00, 0x41, 0x36, 0x08, 0x00}, // 125: }
    {0x10, 0x08, 0x08, 0x10, 0x08}, // 126: ~
};


// SSD1306 initialization commands
static const uint8_t ssd1306_init_commands[] = {
    0xAE, // Display off
    0xD5, 0x80, // Set display clock divide ratio
    0xA8, SSD1306_HEIGHT - 1, // Set multiplex
    0xD3, 0x00, // Set display offset
    0x40, // Set display start line to 0
    0x8D, 0x14, // Enable charge pump
    0x20, 0x00, // Set memory addressing mode to horizontal
    0xA1, // Set segment re-map
    0xC8, // Set COM output scan direction
    0xDA, 0x12, // Set COM pins hardware configuration
    0x81, 0x7F, // Set contrast control
    0xD9, 0xF1, // Set pre-charge period
    0xDB, 0x40, // Set VCOMH deselect level
    0xA4, // Enable display output GDDRAM
    0xA6, // Set normal display mode (A7 for inverse)
    0xAF // Display on
};

static void ssd1306_send_command(uint8_t command) {
    uint8_t buffer[2] = {0x00, command};
    i2c_write_blocking(i2c_default, SSD1306_I2C_ADDR, buffer, 2, false);
}

void ssd1306_init(SSD1306_t* display, i2c_inst_t* i2c) {
    i2c_init(i2c, 400 * 1000);  // Initialize I2C at 400kHz
    gpio_set_function(I2C_SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(I2C_SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(I2C_SDA_PIN);
    gpio_pull_up(I2C_SCL_PIN);

    display->i2c = i2c;
    memset(display->buffer, 0, sizeof(display->buffer));
    for (uint8_t i = 0; i < sizeof(ssd1306_init_commands); i++) {
        ssd1306_send_command(ssd1306_init_commands[i]);
    }
    ssd1306_clear(display);
    ssd1306_update_display(display);
}

void ssd1306_update_display(SSD1306_t* display) {
    ssd1306_send_command(0x21); // Column address
    ssd1306_send_command(0);    // Start column
    ssd1306_send_command(SSD1306_WIDTH - 1); // End column
    ssd1306_send_command(0x22); // Page address
    ssd1306_send_command(0);    // Start page
    ssd1306_send_command((SSD1306_HEIGHT / 8) - 1); // End page

    uint8_t buffer[SSD1306_WIDTH + 1];
    buffer[0] = 0x40;
    for (uint8_t page = 0; page < SSD1306_HEIGHT / 8; page++) {
        for (uint8_t col = 0; col < SSD1306_WIDTH; col++) {
            buffer[col + 1] = display->buffer[page * SSD1306_WIDTH + col];
        }
        i2c_write_blocking(i2c_default, SSD1306_I2C_ADDR, buffer, SSD1306_WIDTH + 1, false);
    }
}

void ssd1306_clear(SSD1306_t* display) {
    for (int i = 0; i < sizeof(display->buffer); i++) {
        display->buffer[i] = 0x00;
    }
}

// Draw a single pixel
void ssd1306_draw_pixel(SSD1306_t* display, uint8_t x, uint8_t y, bool on) {
    if (x >= SSD1306_WIDTH || y >= SSD1306_HEIGHT) return;
    uint16_t byte_idx = x + (y / 8) * SSD1306_WIDTH;
    uint8_t bit_mask = 1 << (y % 8);
    if (on) {
        display->buffer[byte_idx] |= bit_mask;
    } else {
        display->buffer[byte_idx] &= ~bit_mask;
    }
}

// Draw a character at specified position
void ssd1306_draw_char(SSD1306_t* display, uint8_t x, uint8_t y, char c) {
    if (c < 32 || c > 126) return;
    const uint8_t* char_data = font_5x7[c - 32];
    for (uint8_t col = 0; col < 5; col++) {
        uint8_t pixels = char_data[col];
        for (uint8_t row = 0; row < 7; row++) {
            bool on = pixels & (1 << row);
            ssd1306_draw_pixel(display, x + col, y + row, on);
        }
    }
}

// Draw a string at specified position
void ssd1306_draw_string(SSD1306_t* display, uint8_t x, uint8_t y, const char* str) {
    while (*str) {
        ssd1306_draw_char(display, x, y, *str++);
        x += 6;  // Move to the right for the next character (5-pixel width + 1 pixel spacing)
    }
}