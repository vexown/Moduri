; Code from pico-examples (modified by me a bit)
;
; Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
;
; SPDX-License-Identifier: BSD-3-Clause
;

; Side-set pin 0 is used for PWM output
.pio_version 0 // only requires PIO version 0

.program pwm
.side_set 1 opt

    pull noblock    side 0 ; Pull from FIFO to OSR if available, else copy X to OSR.
    mov x, osr             ; Copy most-recently-pulled value back to scratch X
    mov y, isr             ; ISR contains PWM period. Y used as counter.
countloop:
    jmp x!=y noset         ; Set pin high if X == Y, keep the two paths length matched
    jmp skip        side 1
noset:
    nop                    ; Single dummy cycle to keep the two paths the same length
skip:
    jmp y-- countloop      ; Loop until Y hits 0, then pull a fresh PWM value from FIFO

% c-sdk {
static inline void PWM_Program_InitAndRun(const uint PWM_PIN, const uint32_t ON_time) 
{
    /* Call this function in your applicaton to use this PIO program in a simple way */
    /* Provide the following parameters:
        - PWM_PIN, configues on which GPIO pin the PWM signal will be generated
        - ON_time, decides the duty cycle - how long the signal is high (measured in number of ticks in the PWM cycle: 0 to 65535 => 0% to 100% duty cycle) */
    
    /* PWM configuration */
    const uint32_t PWM_RESOLUTION_BITS = 16u;
    const uint32_t PWM_PERIOD_MAX_WRAP = ((1u << PWM_RESOLUTION_BITS) - 1u); //65535 (uint16_t max), total number of 'steps' or 'ticks' in the PWM cycle
   
    /* PIO configuration */
    PIO_HAL_Config_t config = 
    {
        .pio_instance = pio0,       //Choose PIO instance - RP2350 has 3 Ã— Programmable IO (PIO) blocks, each with 4 state machines (12 SMs total)
        .state_machine_num = 0,     //Select state machine number in the PIO instance (here we choose the first one out of 4)
        .program = &pwm_program,  //Program instructions (generated by the PIO assembler from the .pio file provided by the user)
        .program_length = pwm_program.length,         //Number of instructions in the program
        .clock_div = 1.0f,                                  //Set the clock divider
        .pin_base = PWM_PIN,                                //GPIO pin number to use
        .pin_count = 1,                                     //Number of pins to use
        .set_pins_as_output = true,                         //Set pins as output
        .default_config = pwm_program_get_default_config,  //Function pointer to get the default configuration for the PIO program (will be generated by the PIO assembler)
        .pin_type = PIO_PIN_SIDESET
    };

    PIO_HAL_Status_t status;

    status = PIO_Init(&config);
    if(status != PIO_HAL_OK) 
    {
        printf("PIO Init failed! Status: %d\n", status);
    }

    status = PIO_TX_FIFO_Write(&config, PWM_PERIOD_MAX_WRAP);
    if(status != PIO_HAL_OK) 
    {
        printf("PIO TX FIFO Write failed! Status: %d\n", status);
    }

    PIO_ExecuteInstruction(&config, pio_encode_pull(false, false));
    PIO_ExecuteInstruction(&config, pio_encode_out(pio_isr, 32));

    status = PIO_EnableSM(&config);
    if(status != PIO_HAL_OK) 
    {
        printf("PIO Enable SM failed! Status: %d\n", status);
    }

    status = PIO_TX_FIFO_Write(&config, ON_time);
    if(status != PIO_HAL_OK) 
    {
        printf("PIO TX FIFO Write failed! Status: %d\n", status);
    }
}
%}
